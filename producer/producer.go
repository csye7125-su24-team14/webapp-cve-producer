package producer

import (
	"context"
	"net/http"
	"os"
	"strconv"
	"strings"

	"github.com/Shopify/sarama"
	"github.com/joho/godotenv"
	zlog "github.com/rs/zerolog/log"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/propagation"
	"go.opentelemetry.io/otel/trace"
)

var producer sarama.SyncProducer

func init() {
	// loads values from .env into the system
	if err := godotenv.Load(); err != nil {
		zlog.Info().Msg("sad .env file found")
	}
}

var tracer = otel.Tracer("producer") // Tracer instance library name
func Main() {
	brokersUrl := strings.Split(os.Getenv("kafkaURL"), ",")
	// brokersUrl := []string{
	// 	"mykafka-controller-0.mykafka-controller-headless.default.svc.cluster.local:9092",
	// 	"mykafka-controller-1.mykafka-controller-headless.default.svc.cluster.local:9092",
	// 	"mykafka-controller-2.mykafka-controller-headless.default.svc.cluster.local:9092",
	// }
	var err error
	topic := os.Getenv("TOPIC_NAME")
	producer, err := ConnectProducer(brokersUrl, topic)
	if err != nil {
		// log.Fatalf("Failed to connect to Kafka producer: %v", err)
		zlog.Fatal().Err(err).Msg("Failed to connect to Kafka producer")
	}
	defer producer.Close()

	ctx := context.Background()

	// For testing to print out traces to the console
	// exp, err := newConsoleExporter()
	exp, err := newOTLPExporter(ctx)

	if err != nil {
		zlog.Fatal().Msgf("failed to initialize exporter: %v", err)
	}

	// Create a new tracer provider with a batch span processor and the given exporter.
	tp := newTraceProvider(exp)

	// Handle shutdown properly so nothing leaks.
	defer func() { _ = tp.Shutdown(ctx) }()

	otel.SetTracerProvider(tp)

	SaveCve(producer, topic)

	resp, err := http.Get("http://127.0.0.1:15000/ready")
	if err != nil {
		zlog.Info().Msgf("Failed to check Envoy readiness: %v", err)
	} else if resp.StatusCode == http.StatusOK {
		zlog.Info().Msgf("Envoy is ready")
		resp, err := http.Post("http://127.0.0.1:15000/quitquitquit", "application/json", nil)
		if err != nil {
			zlog.Warn().Err(err).Msg("Failed to stop Envoy sidecar")
		}
		defer resp.Body.Close()

		if resp.StatusCode != http.StatusOK {
			zlog.Info().Msgf("Failed to stop Envoy sidecar, status code: %d", resp.StatusCode)
		}

		zlog.Info().Msgf("Envoy sidecar stopped successfully")

	} else {
		zlog.Info().Msgf("Envoy not ready, status code: %d", resp.StatusCode)
	}

}

func ConnectProducer(brokersUrl []string, topic string) (sarama.SyncProducer, error) {

	config := sarama.NewConfig()
	// config.Version = sarama.V2_6_0_0
	config.Producer.Return.Successes = true
	config.Producer.RequiredAcks = sarama.WaitForAll
	config.Producer.Retry.Max = 5
	// SASL configuration
	config.Net.SASL.Enable = true
	config.Net.SASL.Mechanism = sarama.SASLTypeSCRAMSHA256
	config.Net.SASL.User = os.Getenv("USERNAME")
	config.Net.SASL.Password = os.Getenv("PASSWORD")

	config.ClientID = "sasl_scram_client"
	config.Metadata.Full = true

	config.Net.SASL.Handshake = true

	config.Net.SASL.SCRAMClientGeneratorFunc = func() sarama.SCRAMClient { return &XDGSCRAMClient{HashGeneratorFcn: SHA256} }

	// nf.Net.SASL.SCRAMClientGeneratorFunc =
	// conf.Net.SASL.Mechanism = sarama.SASLTypeSCRAMSHA256

	// if *useTLS {
	// 	conf.Net.TLS.Enable = true
	// 	conf.Net.TLS.Config = createTLSConfiguration()
	admin, err := sarama.NewClusterAdmin(brokersUrl, config)
	if err != nil {
		zlog.Fatal().Err(err).Msg("Failed to create Kafka admin client")
	}
	defer func() {
		if err := admin.Close(); err != nil {
			zlog.Fatal().Err(err).Msg("Failed to close Kafka admin client")
		}
	}()

	partitionsEnv := os.Getenv("PARTITIONS")
	numPartitions, err := strconv.Atoi(partitionsEnv)
	if err != nil {
		numPartitions = 3
		zlog.Warn().Err(err).Msg("Invalid PARTITIONS value")
	}
	replicasEnv := os.Getenv("REPLICAS")
	replicationFactor, err := strconv.Atoi(replicasEnv)
	if err != nil {
		replicationFactor = 3
		zlog.Warn().Err(err).Msg("Invalid replicasEnv value")
	}

	topics, err := admin.ListTopics()
	if err != nil {
		zlog.Fatal().Err(err).Msg("Failed to list topics")
	}

	if _, exists := topics[topic]; !exists {
		// Create the topic
		topicDetail := &sarama.TopicDetail{
			NumPartitions:     int32(numPartitions),
			ReplicationFactor: int16(replicationFactor),
		}

		err = admin.CreateTopic(topic, topicDetail, false)
		if err != nil {
			zlog.Fatal().Err(err).Msg("Failed to create topic")
		}
		zlog.Info().Msg("Topic " + topic + " created successfully")
	} else {
		zlog.Info().Msg("Topic " + topic + " already exists")
	}

	topics, err = admin.ListTopics()
	if err == nil {
		zlog.Info().Msg("Existing topics and their details:")
		for topic, details := range topics {
			zlog.Info().Msgf("Topic: %s, Details: %+v", topic, details)
		}

	}
	conn, err := sarama.NewSyncProducer(brokersUrl, config)
	if err != nil {
		return nil, err
	}

	return conn, nil
}

func PushCveToQueue(topic string, key string, cve []byte, producer sarama.SyncProducer) error {
	ctx, span := tracer.Start(context.Background(), "produce_message", trace.WithAttributes(
		attribute.String("cveId", key),
	))
	defer span.End()

	msg := &sarama.ProducerMessage{
		Topic: topic,
		Key:   sarama.StringEncoder(key),
		Value: sarama.StringEncoder(cve),
	}
	// Inject the tracing context into the message headers
	propagator := propagation.NewCompositeTextMapPropagator(propagation.TraceContext{}, propagation.Baggage{})
	// propagator := otel.GetTextMapPropagator()

	propagator.Inject(ctx, NewMessageCarrier(msg))
	// zlog.Info().Msgf("Number of headers before injection: %d", len(msg.Headers))
	// otel.GetTextMapPropagator().Inject(ctx, NewMessageCarrier(msg))
	// zlog.Info().Msgf("Number of headers after injection: %d", len(msg.Headers))
	// zlog.Info().Msgf("TextMapPropagator type: %T", otel.GetTextMapPropagator())
	zlog.Info().Str("trace_id", span.SpanContext().TraceID().String()).Msg("Produced message")
	partition, offset, err := producer.SendMessage(msg)
	if err != nil {
		return err
	}
	zlog.Info().Msgf("Message is stored in topic(%s)/partition(%d)/offset(%d)", topic, partition, offset)

	return nil
}

// MessageCarrier implements TextMapCarrier for sarama.ProducerMessage
type MessageCarrier struct {
	msg *sarama.ProducerMessage
}

func NewMessageCarrier(msg *sarama.ProducerMessage) *MessageCarrier {
	return &MessageCarrier{msg: msg}
}

func (mc *MessageCarrier) Get(key string) string {
	for _, header := range mc.msg.Headers {
		if string(header.Key) == key {
			return string(header.Value)
		}
	}
	return ""
}

func (mc *MessageCarrier) Set(key string, value string) {
	mc.msg.Headers = append(mc.msg.Headers, sarama.RecordHeader{
		Key:   []byte(key),
		Value: []byte(value),
	})
}

func (mc *MessageCarrier) Keys() []string {
	keys := make([]string, len(mc.msg.Headers))
	for i, header := range mc.msg.Headers {
		keys[i] = string(header.Key)
	}
	return keys
}
