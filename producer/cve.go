package producer

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sync"

	"github.com/Shopify/sarama"
)

const (
	numPartitions  = 3
	numConcurrency = 2 // Number of goroutines to use for processing files
)

var kafkaTopic = "cve"

type CveData struct {
	Containers  json.RawMessage `json:"containers"`
	CveMetadata CveMetadata     `json:"cveMetadata"`
	DataType    string          `json:"dataType"`
	DataVersion string          `json:"dataVersion"`
}

type CveMetadata struct {
	AssignerOrgId     string `json:"assignerOrgId"`
	AssignerShortName string `json:"assignerShortName"`
	CveId             string `json:"cveId"`
	DatePublished     string `json:"datePublished"`
	DateReserved      string `json:"dateReserved"`
	DateUpdated       string `json:"dateUpdated"`
	State             string `json:"state"`
}

func SaveCve(producer sarama.SyncProducer, topic_name string) {
	kafkaTopic = topic_name
	downloadAndUnzipData()

	rootFolder := "/tmp/cve_data"

	fileChan := make(chan string, 100)
	var wg sync.WaitGroup

	// Start worker goroutines
	for i := 0; i < numConcurrency; i++ {
		wg.Add(1)
		go worker(fileChan, &wg, producer)
	}

	// Walk through the directory and send file paths to the channel
	err := filepath.Walk(rootFolder, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() && info.Name() != "delta.json" && info.Name() != "deltaLog.json" && filepath.Ext(path) == ".json" {
			fileChan <- path
		}
		return nil
	})
	if err != nil {
		log.Println("Error walking through folder: %v", err)
	}

	close(fileChan)
	wg.Wait()

	producer.Close()

	fmt.Println("Finished processing all files")
}

func worker(fileChan <-chan string, wg *sync.WaitGroup, producer sarama.SyncProducer) {
	defer wg.Done()

	for path := range fileChan {
		processFile(path, producer)
	}
}

func processFile(path string, producer sarama.SyncProducer) {
	file, err := os.Open(path)
	if err != nil {
		log.Printf("Error opening file %s: %v", path, err)
		return
	}
	defer file.Close()

	byteValue, err := ioutil.ReadAll(file)
	if err != nil {
		log.Printf("Error reading file %s: %v", path, err)
		return
	}

	var cveData CveData
	if err := json.Unmarshal(byteValue, &cveData); err != nil {
		log.Printf("Failed to unmarshal JSON data from file %s: %v", path, err)
		return
	}

	err = PushCveToQueue(kafkaTopic, cveData.CveMetadata.CveId, byteValue, producer)
	if err != nil {
		log.Printf("Failed to push CVE data to Kafka: %v", err)
	}

}
